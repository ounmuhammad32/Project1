{% extends "base.html" %}
{% block content %}
    <div class="container-fluid mb-4">
        <img src="{{ url_for('static', filename='images/c1.png') }}"
             class="img-fluid" alt="container">
    </div>
    <div class="container-fluid">

        <p class="mb-3"><em><strong>"Continuous Integration</strong> (CI) use case is a staple of modern software
            development in the digital age. It's unlikely that you hear the word "DevOps" without a reference to
            "Continuous Integration and Continuous Delivery" (CI/CD) soon after. In the most basic sense, the CI part of
            the equation enables development teams to automate building and testing their code.

            When practicing CI, teams collaborate on projects by using a shared repository to store, modify and track
            frequent changes to their codebase. Developers check in, or integrate, their code into the repository
            multiple times a day and rely on automated tests to run in the background. These automated tests verify the
            changes by checking for potential bugs and security vulnerabilities, as well as performance and code quality
            degradations. Running tests as early in the software development lifecycle as possible is advantageous in
            order to detect problems before they intensify.

            CI makes software development easier, faster, and less risky for developers. By automating builds and tests,
            developers can make smaller changes and commit them with confidence. They get earlier feedback on their code
            in order to iterate and improve it quickly increasing the overall pace of innovation. Studies done by DevOps
            Research and Assessment (DORA) have shown that robust DevOps practices lead to improved business outcomes.
            All of these "DORA 4" metrics can be improved by using CI:"</em></p>

    </div>
    <div class="row align-items stretch">

        <div class="col-6 py-3">


            <ol class="list-unstyled">
                <li>Lead time: Early feedback and build/test automation help decrease the time it takes to go from code
                    committed to code successfully running in production.
                </li>
                <li>Deployment frequency: Automated build and test is a pre-requisite to automated deploy.
                </li>
                <li>Time to restore service: Automated pipelines enable fixes to be deployed to production faster
                    reducing Mean Time to Resolution (MTTR)
                </li>
                <li>Change failure rate: Early automated testing greatly reduced the number of defects that make their
                    way out to production.

                </li>
            </ol>

        </div>


        <div class="col-6 mt-3">
            <img src="{{ url_for('static', filename='images/c2.png') }}" class="img-fluid" alt="prodwork">
            <img src="{{ url_for('static', filename='images/c3.png') }}" class="img-fluid py-2" alt="workflow">
        </div>

    </div>
    <div class="col-5 py-2">


    </div>



    </div>
    </div>
{% endblock %}
